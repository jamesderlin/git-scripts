#!/usr/bin/env python3

"""
Interactively manages and resolves merge conflicts.

Unlike `git mergetool`, opens conflicting files in a text editor instead of in
a graphical merge tool.  Additionally will never automatically add files that
still contain conflict markers.
"""

# TODO:
# * Add option to mark files with conflict markers as unresolved.
#   <https://stackoverflow.com/questions/2780483/>
# * Add option to re-resolve resolved conflicts.
# * Add options to automatically resolve conflicts with ours or theirs.

import argparse
import enum
import os
import re
import subprocess
import sys

import gitutils


conflict_marker_re = re.compile(r"(?:[<]{7})"  # Yours
                                r"|(?:[|]{7})"  # Original
                                r"|(?:[=]{7})"  # Theirs
                                r"|(?:[>]{7})")  # End


def find_conflict_marker(file_path):
    """
    Returns the line number of the first line that contains a merge conflict
    marker the specified file.

    Lines are numbered starting from 1.
    """
    with open(file_path) as f:
        for (line_number, line) in enumerate(f, 1):
            if conflict_marker_re.match(line):
                return line_number
    return None


class ConflictStatus(enum.Enum):
    """See `handle_conflicts`."""
    NONE = enum.auto()
    RESOLVED = enum.auto()
    UNRESOLVED = enum.auto()


def handle_conflicts(file_path):
    """
    Prompts to resolve conflicts in the specified file.

    Returns `ConflictStatus.NONE` if no conflicts were detected in the file,
    `ConflictStatus.RESOLVED` if all conflicts were resolved, and
    `ConflictStatus.unresolved` if conflicts remain unresolved.

    Might raise `AbortError` to cancel resolving all remaining conflicts.
    """
    result = ConflictStatus.NONE
    while True:
        line_number = find_conflict_marker(file_path)
        if line_number is None:
            if result == ConflictStatus.UNRESOLVED:
                result = ConflictStatus.RESOLVED
            print(f"Resolved: {file_path}")
            gitutils.run_command(("git", "add", "--", file_path), check=True)
            break

        print(f"Conflicts in: {file_path}")
        result = ConflictStatus.UNRESOLVED

        while True:
            try:
                response = input("(E)dit, (s)kip, (q)uit: ").lower()
            except EOFError:
                response = "q"

            use_default = not response
            response = response.strip()

            if use_default or "edit".startswith(response):
                gitutils.run_editor(file_path, line_number=line_number)
                break

            if "skip".startswith(response):
                return result

            if "quit".startswith(response):
                raise gitutils.AbortError(cancelled=True)

            print(f"Unrecognized input: {response}")

    return result


@gitutils.entrypoint(globals())
def main(argv):
    ap = argparse.ArgumentParser(description=__doc__.strip(), add_help=False)
    ap.add_argument("-h", "--help", action="help",
                    help="Show this help message and exit.")
    ap.add_argument("--verbose", action="store_true",
                    help="Print verbose debugging messages.")
    ap.add_argument("--all", action="store_true",
                    help="Check for conflict markers in all files awaiting "
                         "commit, not just unmerged files.")

    args = ap.parse_args(argv[1:])

    gitutils.verbose = args.verbose
    result = gitutils.run_command(("git", "status", "--porcelain", "-z"),
                                  stdout=subprocess.PIPE,
                                  universal_newlines=True,
                                  check=True)
    tokens = result.stdout.split("\0")

    encountered_conflicts = False

    git_root = gitutils.git_root()

    # Reverse so that we can pop from the back for efficiency.
    tokens.reverse()
    while tokens:
        token = tokens.pop()
        if not token:
            break

        if token[2] != " ":
            raise Exception("Unexpected token")
        code = token[0:2]

        # `git status --porcelain` returns paths relative to the root of the
        # current git repository, not relative to the current working
        # directory.
        file_path = token[3:]
        file_path = os.path.relpath(os.path.join(git_root, file_path))

        if "R" in code:
            _original_file_path = tokens.pop()  # noqa: F841

        if code in ("??", "!!"):
            # Untracked or ignored files.
            pass
        elif code == "AU":
            print(f"Conflicts in: {file_path} (added by us)")
            encountered_conflicts = True
        elif code == "UA":
            print(f"Conflicts in: {file_path} (added by them)")
            encountered_conflicts = True
        elif code == "DU":
            print(f"Conflicts in: {file_path} (deleted by us)")
            encountered_conflicts = True
        elif code == "UD":
            print(f"Conflicts in: {file_path} (deleted by them)")
            encountered_conflicts = True
        elif code == "UU" or (args.all and os.path.isfile(file_path)):
            encountered_conflicts \
                = ((handle_conflicts(file_path) != ConflictStatus.NONE)
                   or encountered_conflicts)

    if not encountered_conflicts:
        print("No conflicts detected.")

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv))
