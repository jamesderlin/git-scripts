#!/usr/bin/env python3

"""
Interactively manages and resolves merge conflicts.

Unlike `git mergetool`, opens conflicting files in a text editor instead of in
a graphical merge tool.  Additionally will never automatically add files that
still contain conflict markers.
"""

# TODO:
# * Add option to mark files with conflict markers as unresolved.
#   <https://stackoverflow.com/questions/2780483/>
# * Add option to re-resolve resolved conflicts.
# * Add options to automatically resolve conflicts with ours or theirs.

import argparse
import enum
import os
import re
import subprocess
import sys

import gitutils


conflict_marker_re = re.compile(r"(?:[<]{7})"  # Yours
                                r"|(?:[|]{7})"  # Original
                                r"|(?:[=]{7})"  # Theirs
                                r"|(?:[>]{7})")  # End


def find_conflict_marker(file_path):
    """
    Returns the line number of the first line that contains a merge conflict
    marker the specified file.

    Lines are numbered starting from 1.
    """
    with open(file_path) as f:
        for (line_number, line) in enumerate(f, 1):
            if conflict_marker_re.match(line):
                return line_number
    return None


class ConflictState(enum.Enum):
    """See `handle_conflicts`."""
    NONE = enum.auto()
    RESOLVED = enum.auto()
    UNRESOLVED = enum.auto()


def handle_conflicts(file_path):
    """
    Prompts to resolve conflicts in the specified file.

    Returns `ConflictState.NONE` if no conflicts were detected in the file,
    `ConflictState.RESOLVED` if all conflicts were resolved, and
    `ConflictState.unresolved` if conflicts remain unresolved.

    Might raise `AbortError` to cancel resolving all remaining conflicts.
    """
    result = ConflictState.NONE
    choices = (("e", "edit"), ("s", "skip"), ("q", "quit"))
    prompt = "(E)dit, (s)kip, (q)uit: "
    while True:
        line_number = find_conflict_marker(file_path)
        if line_number is None:
            if result == ConflictState.UNRESOLVED:
                result = ConflictState.RESOLVED
            print(f"Resolved: {file_path}")
            gitutils.run_command(("git", "add", "--", file_path), check=True)
            break

        print(f"Conflicts in: {file_path}")
        result = ConflictState.UNRESOLVED

        response = gitutils.prompt_with_choices(choices, default="e",
                                                prompt=prompt)
        if response is None or response == "q":
            raise gitutils.AbortError(cancelled=True)

        if response == "e":
            gitutils.run_editor(file_path, line_number=line_number)
        elif response == "s":
            return result
        else:
            assert False

    return result


@gitutils.entrypoint(globals())
def main(argv):
    ap = argparse.ArgumentParser(description=__doc__.strip(), add_help=False)
    ap.add_argument("-h", "--help", action="help",
                    help="Show this help message and exit.")
    ap.add_argument("--verbose", action="store_true",
                    help="Print verbose debugging messages.")
    ap.add_argument("--all", action="store_true",
                    help="Check for conflict markers in all files awaiting "
                         "commit, not just unmerged files.")

    args = ap.parse_args(argv[1:])

    gitutils.verbose = args.verbose
    result = gitutils.run_command(("git", "status", "--porcelain",
                                   "--untracked-files=no", "-z"),
                                  stdout=subprocess.PIPE,
                                  universal_newlines=True,
                                  check=True)
    tokens = result.stdout.split("\0")

    git_root = gitutils.git_root()

    # Allowed state transitions for `conflict_summary`:
    #
    # ---> NONE ---> RESOLVED ---> UNRESOLVED <---+
    #       |           |                         |
    #       +-----------+-------------------------+
    conflict_summary = ConflictState.NONE
    tokens_iter = iter(tokens)
    try:
        while True:
            token = next(tokens_iter)
            if not token:
                break

            if token[2] != " ":
                raise Exception("Unexpected token")
            code = token[0:2]

            # `git status --porcelain` returns paths relative to the root of
            # the current git repository, not relative to the current working
            # directory.
            file_path = token[3:]
            file_path = os.path.relpath(os.path.join(git_root, file_path))

            if "R" in code:
                _original_file_path = next(tokens_iter)  # noqa: F841

            if code == "AU":
                print(f"Conflicts in: {file_path} (added by us)")
                conflict_summary = ConflictState.UNRESOLVED
            elif code == "UA":
                print(f"Conflicts in: {file_path} (added by them)")
                conflict_summary = ConflictState.UNRESOLVED
            elif code == "DU":
                print(f"Conflicts in: {file_path} (deleted by us)")
                conflict_summary = ConflictState.UNRESOLVED
            elif code == "UD":
                print(f"Conflicts in: {file_path} (deleted by them)")
                conflict_summary = ConflictState.UNRESOLVED
            elif code == "UU" or (args.all and os.path.isfile(file_path)):
                file_state = handle_conflicts(file_path)
                if file_state == ConflictState.NONE:
                    pass
                elif file_state == ConflictState.RESOLVED:
                    if conflict_summary == ConflictState.NONE:
                        conflict_summary = ConflictState.RESOLVED
                elif file_state == ConflictState.UNRESOLVED:
                    conflict_summary = ConflictState.UNRESOLVED
                else:
                    assert False
    except StopIteration:
        pass

    if conflict_summary == ConflictState.NONE:
        print("No conflicts detected.")
        return 0

    return 0 if conflict_summary == ConflictState.RESOLVED else 1


if __name__ == "__main__":
    sys.exit(main(sys.argv))
